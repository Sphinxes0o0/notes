# 预处理
主要是做一些代码文本的替换工作。(该替换是一个递归逐层展开的过程。)
1. 将所有的#define删除，并展开所有的宏定义
2. 处理所有的条件预编译指令，如：#if  #ifdef #elif #else #endif
3. 处理#include预编译指令，将被包含的文件插进到该指令的位置，这个过程是递归的
4. 删除所有的注释//与/* */
5. 添加行号与文件名标识，以便产生调试用的行号信息以及编译错误或警告时能够显示行号
6. 保留所有的#pragma编译器指令，因为编译器需要使用它们

# 编译
把预处理完的文件进行一系列词法分析（lex）、语法分析（yacc）、语义分析及优化后生成汇编代码，这个过程是程序构建的核心部分。

# 汇编
汇编代码->机器指令

# 链接

这里讲的链接，严格说应该叫静态链接。多个目标文件、库->最终的可执行文件（拼合的过程）。
可执行文件分类：
- linux的ELF文件 -- bin、a、so
- windows的PE文件 -- exe、lib、dll
- mac os x的ELF文件  -- bin、a、dylib

> PE文件与ELF文件都是COFF文件的变种

静态库本质上就是包含一堆中间目标文件的压缩包，就像zip等文件一样，里面的各个中间文件包含的外部符号地址是没有被链接器修正的。

# 符号（Symbol） -- 链接的接口
每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。
在链接中，将函数和变量统称为符号，函数名或变量名就是符号名，函数或变量的地址就是符号值。
每一个目标文件都有一个符号表，符号有以下几种：
1. 定义在本目标文件的全局符号，可被其他目标文件引用
     如：全局变量，全局函数
2. 在本目标文件中引用的全局符号，却没有定义在本目标文件 -- 外部符号（External Symbol）
     如：extern变量，printf等库函数，其他目标文件中定义的函数
3. 段名，这种符号由编译器产生，其值为该段的起始地址
     如：目标文件的.text、.data等
4. 局部符号，内部可见
     如：static变量
链接过程中，比较关心的是上面的第一类与第二类。

# 符号修饰（Name Decoration） 
符号修饰实际就是对变量或函数进行重命名的过程，影响命名的因素有：
1. 语言的不同，修饰规则有差别
     如：foo函数，在C语言中会被修饰成_foo，在Fortran语言中会被修饰成_foo_
2. 面向对象语言（如：C++）引入的特性
     如：类、继承、虚机制、重载、命名空间（namespace）等

# 函数签名（Function Signature）

函数签名用于识别不同的函数，包括函数名、它的参数类型及个数、所在的类和命名空间、调用约定类型及其他信息.

# 弱引用与强引用
对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，须被正确决议，如果没有找到该符号的定义，编译器就会报符号为定义的错误，这种被称为强引用；
与之对应还有一种弱引用，在处理弱引用时，即使该符号未被定义，链接器也不会报错，默认其为0或一个特殊的值。
GCC可以通过"__attribute__((weakref))"来声明一个外部函数的引用为弱引用。
这种弱符号和弱引用对于库来说十分有用，库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；
或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；
如果去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。

# 总结
对于链接器来说，整个链接过程，就是将多个输入目标文件合成一个可执行二进制文件。
现代链接器，基本都是采用两步链接的方法：
1. 空间与地址分配
     扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表中。
这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。

2. 符号解析与重定位
    使用上面第一步中收集的所有信息，读取输入文件中段的数据、重定位信息（有一个重定位表Relocation Table），并且进行符号解析与重定位、调整代码中的地址（外部符号）等。

# 服务发现

## 基本流程

* Register, 服务启动时候进行注册

* Query, 查询已注册服务信息

* Healthy Check,确认服务状态是否健康

整个过程很简单。大致就是在服务启动的时候，先去进行注册，并且定时反馈本身功能是否正常。由服务发现机制统一负责维护一份正确或者可用的服务清单。因此，服务本身需要能随时接受查下，反馈调用方服务所要的信息。

## 注册

一整套服务发现机制顺利运行，需要维护一份可用的服务列表。包含服务注册与移除功能，以及健康检查。

常见的注册模式

### 自主注册

自主注册模式，由服务(client)本身来维护。
每个服务启动后，需要到统一的服务注册中心进行注册登记，服务正常终止后，也可以到注册中心移除自身的注册记录。
在服务执行过程中，通过不断的发送心跳信息，来通知注册中心，本服务运行正常。注册中心只要超过一定的时间没有收到心跳消息，
就可以将这个服务状态判断为异常，进而移除该服务的注册记录。

### 第三方注册 
这个模式与自主注册相比，区别是健康检查的动作不是由服务本身(client)来负责，而是由第三方服务来确认。
因为有时候服务自身发送心跳信息的方式并不精确，因为可能服务本身已经存在故障，某些接口功能不可用，
但仍然可以不断的发送心跳信息，导致注册中心没有发觉该服务已经异常，从而源源不断的将流量打到已经异常的服务上来。
所以, 确认服务是否正常运转的健康检查机制，就不能只依靠心跳，必须通过其它第三方的验证，不断的从外部来确认服务本身的健康状态。

在实际应用中, 需要根据需求合理搭配服务, 和管理机制.


## 发现

发现机制主要包括三种：

* 服务提供者：
服务启动时将服务信息注册到注册中心，服务退出时将注册中心的服务信息删除掉。

* 服务消费者：
从服务注册表获取服务提供者的最新网络位置等服务信息，维护与服务提供者之间的通信。

* 注册中心：
服务提供者和服务消费者之间的一个桥梁

服务发现机制的关键部分是注册中心。注册中心提供管理和查询服务注册信息的API。
当服务提供者的实例发生变更时（新增/删除服务），服务注册表更新最新的状态列表，并将其最新列表以适当的方式通知给服务消费者。


### 常用的发现模式

#### 客户端发现模式

首先要进行的是到服务注册中心获取服务列表，然后再根据调用端本地的负载均衡策略，进行服务调用:

* 1.服务提供者向注册中心进行注册，提交自己的相关信息 (register)

* 2.服务消费者定期从注册中心获取服务提供者列表 (keep alive)

* 3.服务消费者通过自身的负载均衡算法，在服务提供者列表里面选择一个合适的服务提供者，进行访问

#### 服务端发现模式。
* 1 服务提供者向注册中心进行服务注册 
* 2 注册中心提供负载均衡功能， 
* 3 服务消费者去请求注册中心，由注册中心根据服务提供列表的健康情况，选择合适的服务提供者供服务消费者调用

> 本质区别在于，客户端是否保存服务列表信息

### 实现方案

#### file

以文件的形式实现服务发现，这是一个比较简单的方案。
其基本原理就是将服务提供者的信息(ip:port)写入文件中，服务消费者加载该文件，
获取服务提供者的信息，根据一定的策略，进行访问。

需要注意的是，因为以文件形式提供服务发现，服务消费者要定期的去访问该文件，
以获得最新的服务提供者列表，这里有个小优化点，就是可以有个线程定时去做该任务，
首先去用该文件的最后一次修改时间跟服务上一次读取文件时候存储的修改时间做对比，
如果时间一致，表明文件未做修改，那么就不需要重新做加载了，反之，重新加载文件。

文件方式实现服务发现，其特点显而易见：

* 优点：
实现简单，去中心化

* 缺点：
需要服务消费者去定时操作，如果某一个文件推送失败，那么就会造成异常现象

> SOME/IP 就是通过文件的方式实现.

#### 其他第三方实现:

* zookeeper
* redis
* etcd

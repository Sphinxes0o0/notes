# 网络IO模型

网络IO模型主要用于描述如何处理输入和输出操作，特别是在涉及网络通信时的数据传输方式。传统上，有五种主要的网络IO模型，它们分别是：

1. 阻塞IO（Blocking IO）

    在这个模型中，应用程序执行一个IO操作（例如，读取网络数据），该调用会阻塞，直到操作完成。在数据从网络到达并且被复制到应用程序缓冲区之前，应用程序不会继续执行。大部分传统的网络应用使用阻塞IO模型。
    ```
    应用程序                   内核  
        |--- read() ----------->|  
        |                       |  
        |<---- 数据可用 ---------|  
        |                       |  
        |<---- read() 完成 -----|  
    ```
    当客户端请求到达时，服务器执行一个阻塞的read()调用，等待客户端发送请求数据。
    在这个过程中，服务器不能做任何其他事情。

2. 非阻塞IO（Non-blocking IO）

    非阻塞IO模型允许应用程序发出IO操作后立即返回，即使操作尚未完成。如果数据尚未准备好，调用会返回一个错误码，通常是EWOULDBLOCK或EAGAIN。应用程序可以继续做其他工作，但它必须定期轮询IO操作，以确定数据是否已准备好。
    ```
    应用程序                   内核
        |                       |
        |---- read() ---------->|
        |<--- EWOULDBLOCK ------|
        |                       |
        |       ... (等待)       |
        |---- read() ---------->|
        |<--- EWOULDBLOCK ------|
        |                       |
        |       ... (等待)      |
        |---- read() ---------->|
        |<----- 数据可用 --------|
        |                       |
     ```
    一个使用非阻塞套接字的网络应用程序，它在读取数据时不断轮询。
    如果read()调用发现没有数据可读，它会立即返回EWOULDBLOCK。
    应用程序可以在轮询期间执行其他任务。

3. IO复用（IO Multiplexing）

    IO复用使用select或poll系统调用，允许应用程序监视多个IO流（文件描述符）的就绪状态。应用程序在一个单独的阻塞调用中等待多个IO操作中的任何一个完成。当select或poll调用返回时，应用程序可以执行IO操作，而无需担心阻塞，因为已知至少有一个IO操作是准备好的。
    ```
    应用程序                   内核
        |                      |
        |--- select() -------->|
        |                      |
        |                      |--- 等待多个
        |                      |    文件描述符
        |<--- 有描述符就绪 -----|
        |                      |
        |--- read() ---------->|
        |<---- 数据可用 --------|
        |                      |
   ```
   服务器使用select()调用来监视多个连接。
   当有客户端发送数据时，select()会返回，服务器就知道可以从哪个套接字读取数据而不会阻塞。

4. 信号驱动IO（Signal-driven IO）

    信号驱动IO允许应用程序为一个IO操作安装一个信号处理器，然后继续执行，而不是等待IO完成。当数据准备好可以进行IO操作时，应用程序会收到一个SIGIO信号，然后可以处理IO操作而不会被阻塞。
    ```
    应用程序                   内核
        |                      |
        |--- sigaction() ----->|
        |                      |
        |--- read() ---------->|
        |                      |
        |                       --- 等待数据 ---
        |                      |
        |<----- SIGIO ---------|
        |                      |
        |--- read() ---------->|
        |<---- 数据可用 --------|
        |                      |
    ```
    应用程序使用sigaction()设置一个信号处理程序来处理SIGIO，然后继续执行，
    当数据到达并准备好被读取时，内核发送SIGIO信号，应用程序响应信号并读取数据。


5. 异步IO（Asynchronous IO）

    在异步IO模型中，应用程序发起一个IO操作后可以立即开始执行其他任务。与信号驱动IO不同，异步IO的操作会在整个操作完成后通知应用程序。应用程序不需要在IO完成后立即处理数据，因为操作系统会在后台处理所有的IO操作。
    ```
    应用程序                   内核
        |                      |
        |--- aio_read() ------>|
        |                      |
        |                       --- 执行读操作 ---
        |                      |
        |                      |--- 读操作完成
        |<---- 通知完成 --------|
        |                      |
    ```
    应用程序发起一个aio_read()操作，并立即继续执行其他代码。
    当读操作实际完成时，应用程序会收到一个通知，这可能是通过信号或其他异步通知机制。

# Reactor & Proactor 模型

## Reactor模型
Reactor模型是基于事件驱动机制的，它使用非阻塞I/O操作。
在这个模型中，主要有一个Reactor（或者事件循环），它负责监听和分发事件。
事件通常是I/O操作，比如读或写操作准备就绪可以进行处理。
当Reactor检测到一个或多个I/O事件的时候，它会相应地通知相关的处理程序（Handlers）来处理这些事件。

Reactor模型的ASCII流程图如下：

```
[ 应用程序 ]       [ Reactor ]        [ Handlers ]
    |                  |                   |
    | 注册处理程序      |                   |
    |----------------->|                   |
    |                  |                   |
    |                  | 监听事件           |
    |                  |<------------------>|
    |                  |                   |
    |                  | 事件就绪           |
    |                  |------------------>|
    |                  |                   |-> 处理事件
    |                  |                   |
    |                  |<------------------|
```

### 处理流程

1. 应用程序启动并注册需要处理的事件及其对应的处理程序到Reactor。

2. Reactor负责监听事件，它通常是一个无限循环，等待事件的发生（如，使用select, poll, 或epoll）。

3. 当一个事件就绪（比如，一个socket可读），Reactor就将事件分发给之前注册的对应处理程序。

4. 处理程序执行非阻塞操作来处理事件（例如，读取数据、处理数据、发送响应等）。

### 组件

首先来回想一下普通函数调用的机制：  
程序调用某函数，函数执行，程序等待，函数将结果和控制权返回给程序，程序继续处理。

和普通函数调用的不同之处在于：  
应用程序不是主动的调用某个 API 完成处理，而是恰恰相反，Reactor 逆置了事件处理流程，应用程序需要提供相应的接口并注册到 Reactor 上，如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。

Reactor 模型有三个重要的组件：
* 多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。
* 事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。
* 事件处理器：负责处理特定事件的处理函数。

具体流程如下：
1. 注册读就绪事件和相应的事件处理器；
2. 事件分离器等待事件；
3. 事件到来，激活分离器，分离器调用事件对应的处理器；
4. 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制
权。

### 总结
Reactor 模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：
* 响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；
* 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进
程的切换开销；
* 可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；
* 可复用性，reactor 框架本身与具体事件处理逻辑无关，具有很高的复用性；

Reactor 模型开发效率上比起直接使用 IO 复用要高，它通常是单线程的，设计目标是
希望单线程使用一颗 CPU 的全部资源，但也有附带优点，即每个事件处理中很多时候可以
不考虑共享资源的互斥访问。
可是缺点也是明显的，现在的硬件发展，已经不再遵循摩尔定律，CPU 的频率受制于材料的限制不再有大的提升，而改为是从核数的增加上提升能力，当程序需要使用多核资源时，Reactor 模型就会悲剧,


## Proactor模型

Proactor模型是异步I/O（AIO）操作的模型。
在这个模型中，应用程序会发起一个异步I/O操作，并立即返回，继续执行其他任务。
当I/O操作实际完成时，操作系统会通知应用程序，这时应用程序会调用相应的完成处理程序（Completion Handler）来处理I/O操作的结果。

Proactor模型的ASCII流程图如下：

```
[ 应用程序 ]       [ OS/AIO Subsystem ]       [ Completion Handlers ]
     |                       |                             |
     | 发起异步I/O操作        |                             |
     |---------------------->|                             |
     |                       |                             |
     |                       | 完成I/O操作                  |
     |                       |---------------------------->|
     |                       |                             |-> 处理完成的I/O
     |                       |                             |
     |<----------------------|                             |
     | 通知I/O完成            |                             |
```

### 处理流程：

具体流程如下：
1. 处理器发起异步操作，并关注 I/O 完成事件
2. 事件分离器等待操作完成事件
3. 分离器等待过程中，内核并行执行实际的 I/O 操作，并将结果数据存入用户自定义缓冲
区，最后通知事件分离器读操作完成
4. I/O 完成后，通过事件分离器呼唤处理器
5. 事件处理器处理用户自定义缓冲区中的数据

从上面的处理流程，可以发现 proactor 模型最大的特点就是使用异步 I/O。
所有的 I/O 操作都交由系统提供的异步 I/O 接口去执行。工作线程仅仅负责业务逻辑。

在 Proactor 中，用户函数启动一个异步的文件操作。同时将这个操作注册到多路复用器上。
多路复用器并不关心文件是否可读或可写而是关心这个异步读操作是否完成。
异步操作是操作系统完成，用户程序不需要关心。多路复用器等待直到有完成通知到来。
当操作系统完成了读文件操作——将读到的数据复制到了用户先前提供的缓冲区之后，通知多路复用器相关操作已完成。多路复用器再调用相应的处理程序，处理数据。

Proactor 增加了编程的复杂度，但给工作线程带来了更高的效率。Proactor 可以在系统态将读写优化，利用 I/O 并行能力，提供一个高性能单线程模型。
在 windows 上，由于没有 epoll 这样的机制，因此提供了 IOCP 来支持高并发， 由于操作系统做了较好的
优化，windows 较常采用 Proactor 的模型利用完成端口来实现服务器。
在 linux 上，2.6 内核出现了 aio 接口，但 aio 实际效果并不理想，它的出现，主要是解决 poll 性能不
佳的问题，但实际上经过测试，epoll 的性能高于 poll+aio，并且 aio 不能处理 accept，因此 linux 主要还是以 Reactor 模型为主。

在不使用操作系统提供的异步 I/O 接口的情况下，还可以使用 Reactor 来模拟 Proactor，差别是：

使用异步接口可以利用系统提供的读写并行能力，而在模拟的情况下，这需要在用
户态实现。具体的做法只需要这样：
1. 注册读事件（同时再提供一段缓冲区）
2. 事件分离器等待可读事件
3. 事件到来，激活分离器，分离器（立即读数据，写缓冲区）调用事件处理器
4. 事件处理器处理数据，删除事件(需要再用异步接口注册)

Boost.asio 库采用的即为 Proactor 模型。不过 Boost.asio 库在 Linux 平台采用
epoll 实现的 Reactor 来模拟 Proactor，并且另外开了一个线程来完成读写调度。

#### 同步 I/O 模拟 Proactor 模型
流程如下：
1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。
2. 主线程调用 epoll_wait 等待 socket 上有数据可读。
3. 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，
直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
4. 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。
5. 主线程调用 epoll_wait 等待 socket 可写。
6. 当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户
请求的结果。


## 对比
两个模式的相同点，都是对某个 IO 事件的事件通知(即告诉某个模块，这个 IO 操作可
以进行或已经完成)。
在结构上两者也有相同点：demultiplexor 负责提交 IO 操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调注册处理函数。

不同点在于，异步情况下(Proactor)，当回调注册的处理函数时，表示 IO 操作已经完成；
同步情况下(Reactor)，回调注册的处理函数时，表示 IO 设备可以进行某个操作(can read or can write)，注册的处理函数这个时候开始提交操作。

这两个模型的关键差异在于：

* Reactor：应用程序负责在操作就绪时进行实际的I/O操作（即，Reactor通知你“可以读取或写入数据了”，然后你去执行那个操作）。

* Proactor：应用程序只需启动操作和处理结果，实际的I/O操作是由操作系统异步完成的（即，Proactor告诉你“读取或写入操作已经完成了”，然后你处理这个结果）。
